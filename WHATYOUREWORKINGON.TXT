using System;
using System.Diagnostics;
using VoxelEngine_Silk.Net_1._0.World;

namespace VoxelEngine_Silk.Net_1._0.World;

public enum BiomeType { Desert, Plains, Forest, Tundra, Mountains, Ocean, River }

public struct BiomeSettings
{
    public float BaseHeight;
    public float Variation;
    public float Frequency;
}

public static class BiomeManager
{
    public const float SEA_LEVEL = 62f;
    public const float RIVER_THRESHOLD = 0.04f;
    public const float LAND_SHARPNESS = 10.0f;

    public static void InitializeNoise(VoxelWorld world, int seed)
    {
        // CONTINENTAL: Increased frequency and octaves for "Ripped Paper" landmasses
        world.ContinentalNoise.SetSeed(seed);
        world.ContinentalNoise.SetNoiseType(FastNoiseLite.NoiseType.OpenSimplex2);
        world.ContinentalNoise.SetFrequency(0.0005f); // Faster change = smaller biomes/oceans
        world.ContinentalNoise.SetFractalType(FastNoiseLite.FractalType.FBm);
        world.ContinentalNoise.SetFractalOctaves(5); // Adds grainy detail
        world.ContinentalNoise.SetFractalLacunarity(2.0f);
        world.ContinentalNoise.SetFractalGain(0.5f);

        // WARP NOISE: High frequency noise used to jitter coordinates
        world.ErosionNoise.SetSeed(seed + 10);
        world.ErosionNoise.SetNoiseType(FastNoiseLite.NoiseType.OpenSimplex2);
        world.ErosionNoise.SetFrequency(0.008f); 

        // HUMIDITY: Ridged fractal for "veiny" moisture patterns
        world.HumidityNoise.SetSeed(seed + 2);
        world.HumidityNoise.SetNoiseType(FastNoiseLite.NoiseType.OpenSimplex2);
        world.HumidityNoise.SetFractalType(FastNoiseLite.FractalType.Ridged);
        world.HumidityNoise.SetFrequency(0.0004f);

        // TEMPERATURE: FBm for more organic heat maps
        world.TempNoise.SetSeed(seed + 3);
        world.TempNoise.SetNoiseType(FastNoiseLite.NoiseType.OpenSimplex2);
        world.TempNoise.SetFractalType(FastNoiseLite.FractalType.FBm);
        world.TempNoise.SetFractalOctaves(3);
        world.TempNoise.SetFrequency(0.00015f);

        world.RiverNoise.SetSeed(seed + 4);
        world.RiverNoise.SetNoiseType(FastNoiseLite.NoiseType.OpenSimplex2);
        world.RiverNoise.SetFrequency(0.0012f);

        world.HeightNoise.SetSeed(seed + 5);
        world.HeightNoise.SetNoiseType(FastNoiseLite.NoiseType.OpenSimplex2);
        world.HeightNoise.SetFrequency(0.012f);
    }

    public static BiomeSettings GetSettings(BiomeType type) => type switch
    {
        BiomeType.Mountains => new BiomeSettings { BaseHeight = 135, Variation = 95, Frequency = 0.02f },
        BiomeType.Forest => new BiomeSettings { BaseHeight = 78, Variation = 20, Frequency = 0.01f },
        BiomeType.Desert => new BiomeSettings { BaseHeight = 70, Variation = 22, Frequency = 0.005f },
        BiomeType.Plains => new BiomeSettings { BaseHeight = 68, Variation = 8, Frequency = 0.008f },
        BiomeType.Tundra => new BiomeSettings { BaseHeight = 67, Variation = 6, Frequency = 0.01f },
        _ => new BiomeSettings { BaseHeight = 64, Variation = 10, Frequency = 0.01f }
    };

    public static byte GetSurfaceBlock(BiomeType type) => type switch
    {
        BiomeType.Desert => (byte)BlockType.Sand,
        BiomeType.Tundra => (byte)BlockType.Snow,
        BiomeType.Mountains => (byte)BlockType.Stone,
        BiomeType.Forest => (byte)BlockType.CoarseDirt,
        BiomeType.Ocean => (byte)BlockType.Sand,
        BiomeType.River => (byte)BlockType.Mud,
        _ => (byte)BlockType.Grass
    };

    public static byte GetFillerBlock(BiomeType type) => type switch
    {
        BiomeType.Desert => (byte)BlockType.Sand,
        BiomeType.Tundra => (byte)BlockType.Dirt,
        _ => (byte)BlockType.Dirt
    };

    public static float GetHeightAt(VoxelWorld world, float wx, float wz)
    {
        // --- DOMAIN WARPING ---
        // Jitter the coordinates by a small amount to create organic, non-geometric borders
        float warpStrength = 20.0f;
        float warpX = world.ErosionNoise.GetNoise(wx, wz) * warpStrength;
        float warpZ = world.ErosionNoise.GetNoise(wx + 500, wz + 500) * warpStrength;
        
        float sx = wx + warpX;
        float sz = wz + warpZ;

        // Use warped coordinates for continental sampling
        float rawCont = world.ContinentalNoise.GetNoise(sx, sz);
        float cont = MathF.Tanh(rawCont * LAND_SHARPNESS);

        // 1. SMOOTH OCEAN FLOOR (Uses rawCont for gentle slope)
        float oceanHeight = (SEA_LEVEL - 1f) + (rawCont * 30f);

        // 2. LAND ELEVATION (Uses warped coordinates)
        float tRaw = world.TempNoise.GetNoise(sx, sz);
        float hRaw = world.HumidityNoise.GetNoise(sx + 5000, sz + 5000);
        float t = (tRaw + 1f) / 2f;
        float h = (hRaw + 1f) / 2f;

        float landBias = Math.Max(0, cont) * 10f; 
        float landBase = SEA_LEVEL + 1.5f + landBias;
        float variation = GetBlendedVariation(world, sx, sz, t, h, cont);
        float landHeight = landBase + variation;

        // 3. CLIFF LOGIC
        float finalHeight;
        const float CLIFF_THRESHOLD = 78f; 

        if (rawCont >= 0) 
        {
            finalHeight = landHeight;
        }
        else 
        {
            if (landHeight > CLIFF_THRESHOLD)
            {
                finalHeight = oceanHeight; // Vertical snap for high terrain
            }
            else
            {
                // Smooth beach for low terrain
                float beachBlend = Math.Clamp(1.0f + (rawCont * 40.0f), 0, 1);
                finalHeight = Lerp(oceanHeight, landHeight, beachBlend);
            }
        }

        // 4. River Carving (Warped rivers look more like natural zig-zags)
        if (rawCont > 0.05f)
        {
            float river = Math.Abs(world.RiverNoise.GetNoise(sx, sz));
            if (river < RIVER_THRESHOLD)
            {
                float riverDepth = (1.0f - (river / RIVER_THRESHOLD)) * 12f;
                finalHeight -= riverDepth;
            }
        }

        return finalHeight;
    }

    private static float GetBlendedVariation(VoxelWorld world, float wx, float wz, float t, float h, float c)
    {
        float totalWeight = 0, weightedHeight = 0;
        // Use erosion unwarped to keep it as a broad structural modifier
        float erosion = world.ErosionNoise.GetNoise(wx * 0.1f, wz * 0.1f);

        foreach (BiomeType type in Enum.GetValues(typeof(BiomeType)))
        {
            if (type == BiomeType.Ocean || type == BiomeType.River) continue;
            float weight = GetBiomeWeight(type, t, h, c);
            if (weight <= 0) continue;

            float smoothWeight = weight * weight * (3 - 2 * weight);
            var s = GetSettings(type);
            float hSample = world.HeightNoise.GetNoise(wx * s.Frequency, wz * s.Frequency) * s.Variation;

            if (type == BiomeType.Mountains)
            {
                hSample *= (1.2f + Math.Max(0, c));
                hSample *= (1.1f - erosion);
            }
            weightedHeight += hSample * smoothWeight;
            totalWeight += smoothWeight;
        }
        return totalWeight > 0 ? (weightedHeight / totalWeight) : 0;
    }

    public static float GetBiomeWeight(BiomeType type, float t, float h, float c)
    {
        if (type == BiomeType.Mountains) return Math.Clamp((h - 0.55f) / 0.2f, 0, 1) * Math.Clamp(c / 0.1f, 0, 1);
        if (type == BiomeType.Tundra) return Math.Clamp((0.32f - t) / 0.2f, 0, 1);
        if (type == BiomeType.Desert) return Math.Clamp((t - 0.68f) / 0.2f, 0, 1) * Math.Clamp((0.42f - h) / 0.2f, 0, 1);
        if (type == BiomeType.Forest) return Math.Clamp((t - 0.25f) / 0.2f, 0, 1) * Math.Clamp((h - 0.48f) / 0.2f, 0, 1);
        return 0.35f; // Plains fallback
    }

    public static BiomeType GetBiomeAt(float temp, float humid, float cont, float riverNoise, float currentHeight)
    {
        if (currentHeight < SEA_LEVEL - 1.0f) return BiomeType.Ocean;
        if (Math.Abs(riverNoise) < RIVER_THRESHOLD) return BiomeType.River;

        float sharpenedCont = MathF.Tanh(cont * LAND_SHARPNESS);
        BiomeType best = BiomeType.Plains;
        float maxWeight = -1f;
        foreach (BiomeType type in Enum.GetValues(typeof(BiomeType)))
        {
            if (type == BiomeType.Ocean || type == BiomeType.River) continue;
            float w = GetBiomeWeight(type, temp, humid, sharpenedCont);
            if (w > maxWeight) { maxWeight = w; best = type; }
        }
        return best;
    }

    private static float Lerp(float a, float b, float t) => a + (b - a) * t;
}